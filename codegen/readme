
IRcode:
	we first out print datalayout, triple, function declarations (like scanf). The actual code starts with main function which calls Maingvars, Mainmain functions. Maingvars contains declaration and initialization of variables in Main class. Mainmain function is the main fucntion of Main class.
	 
Handling class:
	For each class, just like Main, there will be a gvars(global variables) function which contains allotment and initilaization. Allotment refers to getelementptr through which we access the variables of the class. All the attributes of a class are written to this function.
	
Naming convention: Name of a method in the IR code is combination of classname and methodname similar to C convention.

Controlflow: 
	The codegeneration is implemented in “two” passes of AST. 
	Before generating IRcode, we made some virtual tables to make life easy afterwards and used them throughout codegen for various references.The virtual table’s are basically hashmaps of the elemnets. We traversed through all the attributes and methods to collect their data types, class names etc. Hash maps for (classname ,attributes of the class),(classname ,method names of the class).(classname,attributes type),(classname,method return types) are generated. This is all done in the graph_traversal() function.
	
	Now the codegen, the second pass. We traversed through the AST program classes. For each class, we iterated through all features and kept all the attributes together under gvars. The attribute body ir is generated by calling ProcessStr(). If a new object of a class is created then it calls the corresponding attribute definition label.
	In the same class iteration but in a separate iteration of features, we created a label(classname+functionname) and under it processed each method thorugh processstr function. For each class, a class label is declared with the list of types of its attributes.
	
	processstr generates IR code by processing each statement according to its Ast class type, recursively. Assign, Static_dispatch, dispatch, block_list, if_else, while, +, -, *, /, <, <=, =, ~, not, isvoid, new, object, string_const, int_const, bool_const can be types of expressions with some restrictions imposed.
	
Assign
--------
	For handling assign, we need to consider the following two conditions 
		1.The assignment is to the formals of the method: For the assign expression IR is generated by calling ProcessStr() on assign body and the last register value is directly stored in the formal address.                    
		2.The assignment is to the attributes of the class in which the method is defined: We further have two more cases in this.
			a.attribute is defined in the same class as that of method: here we get the attribute address by clalling its getelementptr of the  class and then process the assign body. The last register label is stored to the attribute's getelementptr address.
			b.attribute belongs to the inherited class: In this case the present class pointer is bitcasted to the inherited class where the attribute is defined and the address of the attribute is stored in the register label by calling getelementptr by using the bitcasted class pointer and now the assign body value is stored to this address.
		We need to handle objects according to their base type (int, bool or string) while storing. We kind of generalised the assignment. Consider a,f:int and f is 3. We treated assign f to a and 3 to a in the same way. Load before (while processing expression e1 of assign node) and store them into the required variable (name field of assign node) in assign. 	

static_dispatch
----------------
	Three sub-cases: 
	1.If the caller is of type AST.object:If the object is not void then it goes to case 3 .If the object is void then it gives static dispatch on void error.
	2.If the typeid is IO:  Here the methods out_string, out_int, in_string, in-int are implemented along with other static dispatch calls. 
	For out_string, there are two conditions. First the string to be printed is string_const type. Second the string to be printed is of object type. If the out_string is an object then the object address is obtained by calling getelementptr and the value is loaded. In both the cases,  the out_string is implemented by calling printf on that string value. 
	out_int has also two conditions: out_int on int_const and out_int on object. This is also implemented same as out_string by calling getelementptr. The out_int is implemented by calling printf using %d. 
	in_string and in_int are implemented in the same way. First a memory of the corresponding type is allocated and scanf is called on that address and the address value is stored to the corresponding object address by calling getelementptr.
	3.If the typeid is not IO: The the function call is done by calling the label classname+methodname with its corresponding attributres for which Ir is generated by calling ProcessStr() on each attribute. The classname can be the class in which the method is defined or the inherited class in which the method is defined.
	
	The inherited classname is obtained by calling the parent_type1 function in the codegen.java. It is a recurrsive function. If the attribute name or method name is present in the class the return the callss name else find parent_type1 on class.parent.

dispatch
----------
	Dispatch of methods of same class/inherited class from another method of the class is implemented. If the method is present in same class then the method label is directly called with the present method class pointer. If the method is present in the inherted class then the present method class pointer is bitcasted to the inherited class pointer and then method label is called with the bitcasted class pointer. The actuals of the caller method are passed to ProcessStr for their IR generation. The IO handling in the dispatch is same as that of static dispatch. out_string, out_int, in_string, in-int are implemented even here. This normal dispatch is not handled exhaustively. We dealt with some important cases which we demonstrated through testcases.
	
	(new IO)@IO.out_string goes to static_dispatch.
	new IO.out_string goes to dispatch. And both are handled.
	Even call to main function goes to dispatch. So handling dispatch to an extent is essential.

block_list
------------
	This processes each statement in its expression list iteratively.

if_else
-----------
	We process predicate, if.body, else.body. After processing predicate, we impose an extra check that if predicate is bool_constant or variable whose value is bool, then we perform an icmp to branch on. A function that returns bool being called as predicate handled to some extent. After processing, if.body and else.body, we can't just continue if if_else statement is the last instruction of function. One of if.body and else.body will have to be returned. So we perform this extra check that, if one of them are constants.   

while
-------
	We first process the predicate and check if the predicate is if_else. If we treat the if_else in predicate as normal, in the common if_end label that contains statements after if_else (that would essentially be while.body or while.end), we will not able to know which branch to take. Because ifbody and elsebody generally are to take while though different paths. We won't be able to store different paths and same label. After predicate, branch on while.body or while.end depending on the predicate's value. We just write while.end label here so that the rest of statements that processstr processes automatically come under this.

+,-,*
---------
	add/sub/mul nsw e1, e2
	
/
-------
	sdiv e1, e2
	before performing division, we check if e2 is zero. We do this by comparing the register with 0.  icmp eq e2, 0. And then branch do braching. If yes, branches to exitpro label. Else to continuepro(continue program) label - the rest of the program.

<, <=, =
----------
	<  : icmp slt
	<= : icmp sle
	=  : icmp eq
	
~
--------
	xor with -1

not
-------
	Performed if expr is of bool type. xor with 1. if espr is true, xor with 1 will give false. if espr is false, xor with 1 will give true.

isvoid
---------
	Philosophy: isvoid on int,string, bool is false(not void). isvoid on non-initialised objects is true(void). So the objects on which new is not performed are all void. We stored this information whether an object is initialised. And hard coded the result of isvoid.

new
-------
	Done through the call @_Znwm. We have to pass the size of the object to be created to this function. For finding the size, we used the hashmap in which we stored the datatypes of all attributes of each class and all classes together. size_class function does all the work that's needed. So we add sizes of each datatype. And if an attribute of the class in an object of another class. We recursively find the size of that object. Or the present class is an inherited class, we add the size of that class too which we find recursively though size_class function.

object
--------
	These can be variable names of int, bool or string. Or objects of user defined classes. Since local variables precede global, we first check the variable is a formal. If yes, just load them . Else We check if they belong to the present class or inherited class. If inherited class, we do bitcast and getelementptr. otherwise simply getelementptr. We get the info of index of getelementptr through hashmaps in which we stored the information during first pass. 

string const
-------------
	Whenever we come across a string, we stored them in a list and added them to ir code in the end. And named them according to their index in the list. Then got the size of the string to put it in the printf statement.  

bool_const, int_const
-----------------------
	We stored and loaded the constants so that we can handle them uniformly. This way we don't have to store int values in java code. We didnot choose to hardcode the constants in ir code.

Error handling:
----------------
Division by zero: By comparing with 0 (explained under divsion)
Static dispatch on void: By checking if the caller is initialised (if not void)

-----------------------------------------------------------------------------------------------------------------------------
TESTCASES

hello_world.cl	: The helloworld program. out_string and basic working

bool.cl	: Working of bool variable as if.predicate, bool assignment
bool1.cl	: Working of bool variable as while.predicate and if_else nested in while, bool assignment
testif.cl	: Arithmetic operation (+,-,*,/), equals(=) and nested if_else, in_int
testin.cl	: main calls a function that changes an object of the class and prints it in the main class - dispatch, in_int
testprintscan.cl: negation, complement, in_string, out_string, in_int, out_int
teststrpass.cl	 :	passing strings to a function, static_dispatch
testvoid.cl		 : demonstrates isvoid (if new A statement is uncommented, needs to be run with clang++)
testwhile.cl	 : prints numbers in a loop - while, lt (<)

fib.cl	: recursion and dispatch, if_else, in_int
helloworld.cl	: static_dispatch, dispatch, inherited class, if_else, while, in_string, int and string assignment
leap.cl		: dispatch, nested if_else, int assignment
prime.cl		: if_else as while predicate, int,bool assignment, in_int, dispatch
pyramid.cl	: prints pyramid of stars - nested while, if_else as while predicate and nested while.predicate, dispatch, in_int, int assignment

For errors demonstration:
test1.cl				: error on division by zero (int_const), b/0 gives error	
testdiv.cl			: error on division by zero (object). int i=0, a/i gives error
testdisptcherr.cl : Static dispatch on void where the caller is the object a of class A and function is fun1. class A is inherited by class B. class A has an uninitialised object, a1 of type class C. fun() of class b initialises a1. But as a1 of class A is unitialized, static_dispatch call in fun1 of class A gives error. Static dispatch on void where the caller is normal class is also demonstrated (commented) . 

****use clang++ to run codes that contain new : testdispatcherr,testvoid.cl ***



	    
